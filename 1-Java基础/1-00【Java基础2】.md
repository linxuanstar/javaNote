# 第一章 面向对象思想

Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，
使用Java语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面
向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算
机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去
操作实现。

洗衣服：

* 面向过程：把衣服脱下来-->找一个盆-->放点洗衣粉-->加点水-->浸泡10分钟-->揉一揉-->清洗衣服-->拧干-->晾起来
* 面向对象：把衣服脱下来-->打开全自动洗衣机-->扔衣服-->按钮-->晾起来

面向对象：强调对象，这里的对象就是洗衣机。

面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。 面向对象的语言中，包含了三大基本特征，即封装、继承和多态。

## 1.1 封装

面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。 封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的 方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。

将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。

封装的步骤如下：

1. 使用 `private` 关键字来修饰成员变量。
2. 对需要访问的成员变量，提供对应的一对 `getXxx` 方法 、 `setXxx` 方法。

**private关键字**

`private`关键字的含义：`private`是一个权限修饰符，代表最小权限。可以修饰成员变量和成员方法。被`private`修饰后的成员变量和成员方法，只在本类中才能访问。

使用格式为：`private 数据类型 变量名;`

使用 `private` 修饰成员变量，代码如下：

```java
public class Student {
    private String name;
    private int age;
}
```

提供 `getXxx` 方法 ` setXxx` 方法，可以访问成员变量，代码如下：

```java
public class Student {
    private String name;
    private int age;
    public void setName(String n) {
        name = n;
    }
    public String getName() {
        return name;
    }
    public void setAge(int a) {
        age = a;
    }
    public int getAge() {
        return age;
    }
}
```

**this关键字**

我们发现 `setXxx` 方法中的形参名字并不符合见名知意的规定，修改形参：

```java
public class Student {
    private String name;
    private int age;
    
    public void setName(String name) {
        name = name;
    }
    public void setAge(int age) {
        age = age;
    }
}
```

经过修改和测试，我们发现新的问题，成员变量赋值失败了。也就是说，在修改了 `setXxx()` 的形参变量名后，方法并没有给成员变量赋值！这是由于形参变量名与成员变量名重名，导致成员变量名被隐藏，方法中的变量名，无法访问到成员变量，从而赋值失败。所以，我们只能使用this关键字，来解决这个重名问题。

this代表所在类的当前对象的引用（地址值），即对象自己的引用。

> 方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。

this使用格式：`this.成员变量名;`

```java
public class Student {
    private String name;
    private int age;
    public void setName(String name) {
        //name = name;
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void setAge(int age) {
        //age = age;
        this.age = age;
    }
    public int getAge() {
        return age;
    }
}
```

> 小贴士：方法中只有一个变量名时，默认也是使用 this 修饰，可以省略不写。

**构造方法**

当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。

无论与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。

```java
修饰符 构造方法名(参数列表){
    // 方法体
}
```

构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void。使用构造方法后，代码如下：

```java
public class Student {
    private String name;
    private int age;
    // 无参数构造方法
    public Student() {}
    // 有参数构造方法
    public Student(String name,int age) {
        this.name = name;
        this.age = age;
    }
}
```

1. 如果你提供构造方法，系统会给出无参数构造方法。
2. 如果提供了构造方法，系统将不再提供无参数构造方法。
3. 构造方法是可以重载的，既可以定义参数，也可以不定义参数。

**标准代码JavaBean**

`JavaBean` 是 Java语言编写类的一种标准规范。符合 `JavaBean` 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 `set` 和 `get` 方法。

```java
public class ClassName{
    //成员变量
    //构造方法
    //无参构造方法【必须】
    //有参构造方法【建议】
    //成员方法
    //getXxx()
    //setXxx()
}
```

Lombok，一个Java类库，提供了一组注解，简化POJO实体类开发。

使用步骤如下：

1. 添加lombok依赖。这是Maven里面的依赖。如果不是Maven工程，需要导入jar包。

   ```xml
   <dependency>
       <groupId>org.projectlombok</groupId>
       <artifactId>lombok</artifactId>
       <!--版本可以不用写，因为SpringBoot中已经管理了lombok的版本。-->
       <!--<version>1.18.12</version>-->
   </dependency>
   ```

2. 模型类上添加注解

   Lombok常见的注解有:

   * `@Setter`:为模型类的属性提供setter方法

   * `@Getter`:为模型类的属性提供getter方法

   * `@ToString`:为模型类的属性提供toString方法

   * `@EqualsAndHashCode`:为模型类的属性提供equals和hashcode方法

   * `@Data`:**是个组合注解，包含上面的注解的功能**

   * `@NoArgsConstructor`:提供一个无参构造函数

   * `@AllArgsConstructor`:提供一个包含所有参数的构造函数

   Lombok的注解还有很多，其他的后期用到了，再去补充学习。

   ```java
   @Data
   @AllArgsConstructor
   @NoArgsConstructor
   public class User {
       private Long id;
       private String name;
       private String password;
       private Integer age;
       private String tel;
   }
   ```

Lombok只是简化模型类的编写，我们之前的方法也能用，如果只想要有name和password的构造函数，那就自行编写：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private Long id;
    private String name;
    private String password;
    private Integer age;
    private String tel;

    public User(String name, String password) {
        this.name = name;
        this.password = password;
    }
}
```

## 1.2 继承

多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。如图所示：

![](..\图片\1-00【Java基础】\7继承.png)

其中，多个类可以称为子类，单独那一个类称为父类、超类（superclass）或者基类。

继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。

好处如下：

1. 提高代码的复用性。
2. 类与类之间产生了关系，是多态的前提。

使用extends关键字：

```java
class 父类 {
    ...
}
class 子类 extends 父类 {
    ...
}
```

Java只支持单继承，不支持多继承。支持多层继承(继承体系)，顶层父类是Object类。所有的类默认继承Object，作为父类。子类和父类是一种相对的概念。

**成员变量**

如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。

如果子类父类中出现重名的成员变量，这时的访问是有影响的。代码如下：

```java
class Fu {
    // Fu中的成员变量。
    int num = 5;
}
class Zi extends Fu {
    // Zi中的成员变量
    int num = 6;
    public void show() {
        // 访问父类中的num
        System.out.println("Fu num=" + num);
        // 访问子类中的num
        System.out.println("Zi num=" + num);
    }
}
class ExtendsDemo03 {
    public static void main(String[] args) {
        // 创建子类对象
        Zi z = new Zi();
        // 调用子类中的show方法
        z.show();
    }
}
演示结果：
    Fu num = 6
    Zi num = 6
```

子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 `super` 关键字，修饰父类成员变量，类似于之前学过的 `this` 。使用格式为：`super.父类成员变量名`。

```java
class Zi extends Fu {
    // Zi中的成员变量
    int num = 6;
    public void show() {
        //访问父类中的num
        System.out.println("Fu num=" + super.num);
        //访问子类中的num
        System.out.println("Zi num=" + this.num);
    }
}
演示结果：
    Fu num = 5
    Zi num = 6
```

Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，可以在父类中提供公共的`getXxx`方法和`setXxx`方法。

**覆盖重写**

如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。

如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做方法重写 (Override)。

方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。我们称之为覆盖重写。

```java
class Fu {
    public void show() {
        System.out.println("Fu show");
    }
}
class Zi extends Fu {
    //子类重写了父类的show方法
    public void show() {
        System.out.println("Zi show");
    }
}
public class ExtendsDemo05{
    public static void main(String[] args) {
        Zi z = new Zi();
        // 子类中有show方法，只执行重写后的show方法
        z.show(); // Zi show
    }
}
```

子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从 而进行扩展增强。

1. 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。
2. 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。

**构造方法**

1. 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。
2. 构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构
   造方法中默认有一个 `super()` ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。

```java
class Fu {
    private int n;
    Fu(){
        System.out.println("Fu()");
    }
}
```

```java
class Zi extends Fu {
    Zi(){
        // super（），调用父类构造方法
        super();
        System.out.println("Zi（）");
    }
}
```

```java
public class ExtendsDemo07{
    public static void main (String args[]){
        Zi zi = new Zi();
    }
}
输出结果：
    Fu（）
    Zi（）
```

**super和this**

父类空间优先于子类对象产生

在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空
间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构
造方法调用时，一定先调用父类的构造方法。理解图解如下：

![](..\图片\1-00【Java基础】\8super和this.png)

- super ：代表父类的存储空间标识(可以理解为父亲的引用)。
- this ：代表当前对象的引用(谁调用就代表谁)。

子类的每个构造方法中均有默认的`super()`，调用父类的空参构造。手动调用父类构造会覆盖默认的`super()`。 `super()` 和 `this()` 都必须是在构造方法的第一行，所以不能同时出现。

## 1.3 多态

多态是继封装、继承之后，面向对象的第三大特性。

生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。

多态： 是指同一行为，具有多个不同表现形式。

```java
// 多态格式
父类类型 变量名 = new 子类对象；
变量名.方法名();
```

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写 后方法。

**多态好处**

实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展 性与便利。

```java
public abstract class Animal {
    public abstract void eat();
}
```

```java
class Cat extends Animal {
    public void eat() {
        System.out.println("吃鱼");
    }
}
```

```java
class Dog extends Animal {
    public void eat() {
        System.out.println("吃骨头");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 创建对象
        Cat c = new Cat();
        Dog d = new Dog();
        // 调用showCatEat
        showCatEat(c);
        // 调用showDogEat
        showDogEat(d);
        /*
        以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代
        而执行效果一致
        */
        showAnimalEat(c);
        showAnimalEat(d);
    }
    public static void showCatEat (Cat c){
        c.eat();
    }
    public static void showDogEat (Dog d){
        d.eat();
    }
    public static void showAnimalEat (Animal a){
        a.eat();
    }
}
```

由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当
然可以把Cat对象和Dog对象，传递给方法。

当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，
所以showAnimalEat完全可以替代以上两方法。

不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。

所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。

**引用类型转换**

多态的转型分为向上转型与向下转型两种：

* 向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。

  当父类引用指向一个子类对象时，便是向上转型。

  ```java
  父类类型 变量名 = new 子类类型();
  如：Animal a = new Cat();
  ```

* 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。

  一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。

  ```java
  子类类型 变量名 = (子类类型) 父类变量名;
  如:Cat c =(Cat) a;
  ```

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子 类特有的方法，必须做向下转型。

```java
abstract class Animal {
    abstract void eat();
}
class Cat extends Animal {
    public void eat() {
        System.out.println("吃鱼");
    }
    public void catchMouse() {
        System.out.println("抓老鼠");
    }
}
class Dog extends Animal {
    public void eat() {
        System.out.println("吃骨头");
    }
    public void watchHouse() {
        System.out.println("看家");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 向上转型
        Animal a = new Cat();
        a.eat(); // 调用的是 Cat 的 eat
        // 向下转型
        Cat c = (Cat)a;
        c.catchMouse(); // 调用的是 Cat 的 catchMouse
    }
}
```

转型的过程中，一不小心就会遇到这样的问题

```java
public class Test {
    public static void main(String[] args) {
        // 向上转型
        Animal a = new Cat();
        a.eat(); // 调用的是 Cat 的 eat
        // 向下转型
        Dog d = (Dog)a;
        d.watchHouse(); // 调用的是 Dog 的 watchHouse 【运行报错】
    }
}
```

这段代码可以通过编译，但是运行时，却报出了 `ClassCastException` ，类型转换异常！这是因为明明创建了Cat类型对象，运行时当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。

为了避免`ClassCastException`的发生，Java提供了 `instanceof` 关键字，给引用变量做类型的校验，格式如下：

```java
变量名 instanceof 数据类型
如果变量属于该数据类型，返回true。
如果变量不属于该数据类型，返回false。
```

所以，转换前，我们最好先做一个判断，代码如下：

```java
public class Test {
    public static void main(String[] args) {
        // 向上转型
        Animal a = new Cat();
        a.eat(); // 调用的是 Cat 的 eat
        // 向下转型
        if (a instanceof Cat){
            Cat c = (Cat)a;
            c.catchMouse(); // 调用的是 Cat 的 catchMouse
        } else if (a instanceof Dog){
            Dog d = (Dog)a;
            d.watchHouse(); // 调用的是 Dog 的 watchHouse
        }
    }
}
```

# 第二章 常见的关键字

## 2.1 权限修饰符

在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，

- public：公共的。
- protected：受保护的
- default：默认的
- private：私有的

|                        | public | protected | default（空的） | private |
| ---------------------- | ------ | --------- | --------------- | ------- |
| 同一类中               | √      | √         | √               | √       |
| 同一包中(子类与无关类) | √      | √         | √               |         |
| 不同包的子类           | √      | √         |                 |         |
| 不同包中的无关类       | √      |           |                 |         |

可见，public具有最大权限。private则是最小权限。

编写代码时，如果没有特殊的考虑，建议这样使用权限：

- 成员变量使用 `private` ，隐藏细节。
- 构造方法使用 `public` ，方便创建对象。
- 成员方法使用 `public` ，方便调用方法。

> 不加权限修饰符，其访问能力与default修饰符相同

## 2.2 Static静态关键字

关于 `static` 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属
于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。

被`static`修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属 于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。

static 修饰的内容：

- 是随着类的加载而加载的，且只加载一次。
- 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。
- 它优先于对象存在，所以，可以被所有对象共享。

![](..\图片\1-00【Java基础】\9静态原理.png)

**类变量**

类变量：使用 static关键字修饰的成员变量。定义格式为：`static 数据类型 变量名;`

当 `static` 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改 该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。

**静态方法**

类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。

当 `static` 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 `static` ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。

```java
修饰符 static 返回值类型 方法名 (参数列表){
    // 执行语句
}
```

静态方法调用的注意事项：

- 静态方法可以直接访问类变量和静态方法。
- 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。
- 静态方法中，不能使用this关键字。

> 静态方法只能访问静态成员。

**静态代码块**

静态代码块：定义在成员位置，使用`static`修饰的代码块`{ }`。

- 位置：类中方法外。
- 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。

```java
public class ClassName{
    static {
        // 执行语句
    }
}
```

作用：给类变量进行初始化赋值。用法演示，代码如下：

```java
public class Game {
    public static int number;
    public static ArrayList<String> list;
    static {
        // 给类变量赋值
        number = 2;
        list = new ArrayList<String>();
        // 添加元素到集合中
        list.add("张三");
        list.add("李四");
    }
}
```

> static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况 下，去调用方法。下面将介绍两个工具类，来体现static 方法的便利。

## 2.3 final不可变

子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了 `final` 关键字，用于修饰不可改变内容。

final： 不可改变。可以用于修饰类、方法和变量。

- 类：被修饰的类，不能被继承。
- 方法：被修饰的方法，不能被重写。
- 变量：被修饰的变量，不能被重新赋值。

**修饰类**

```java
final class 类名 {
}
```

查询API发现像 `public final class String` 、 `public final class Math` 、 `public final class Scanner`等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。

**修饰方法**

```java
修饰符 final 返回值类型 方法名(参数列表){
    //方法体
}
```

重写被 `final` 修饰的方法，编译时就会报错。

**修饰变量**

* 局部变脸——基本类型
  基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下：

  ```java
  public class FinalDemo1 {
      public static void main(String[] args) {
          // 声明变量，使用final修饰
          final int a;
          // 第一次赋值
          a = 10;
          // 第二次赋值
          a = 20; // 报错,不可重新赋值
          // 声明变量，直接赋值，使用final修饰
          final int b = 10;
          // 第二次赋值
          b = 20; // 报错,不可重新赋值
      }
  }
  ```

  看一下下面两个代码：

  ```java
  // 代码1
  final int c = 0;
  for (int i = 0; i < 10; i++) {
      c = i;
      System.out.println(c);
  }
  ```

  ```java
  // 代码2
  for (int i = 0; i < 10; i++) {
      final int c = i;
      System.out.println(c);
  }
  ```

  根据 `final` 的定义，代码1报错！代码2没有问题，为什么通过编译呢？因为每次循环，都是一次新的变量c。这也是大家需要注意的地方。

* 局部变量——引用类型
  引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改，代码如下：

  ```java
  public class FinalDemo2 {
      public static void main(String[] args) {
          // 创建 User 对象
          final User u = new User();
          // 创建 另一个 User对象
          u = new User(); // 报错，指向了新的对象，地址值改变。
          // 调用setName方法
          u.setName("张三"); // 可以修改
      }
  }
  ```

* 成员变量
  成员变量涉及到初始化的问题，初始化方式有两种，只能二选一：

  ```java
  // 显示初始化
  public class User {
      final String USERNAME = "张三";
      private int age;
  }
  ```

  ```java
  // 构造方法初始化
  public class User {
      final String USERNAME ;
      private int age;
      public User(String username, int age) {
          this.USERNAME = username;
          this.age = age;
      }
  }
  ```

> 被final修饰的常量名称，一般都有书写规范，所有字母都大写。

## 2.4 abstract抽象

父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。

- 抽象方法： 没有方法体的方法。

  使用 `abstract` 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。抽象方法修饰符不能是`private final static`

  ```java
  修饰符 abstract 返回值类型 方法名 (参数列表)；
  ```

- 抽象类：包含抽象方法的类。

  如果一个类包含抽象方法，那么该类必须是抽象类。

  ```java
  abstract class 类名字 {
  }
  ```

继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。

```java
public class Cat extends Animal {
    public void run (){
        System.out.println("小猫在墙头走~~~")；
    }
}
public class CatTest {
    public static void main(String[] args) {
        // 创建子类对象
        Cat c = new Cat();
        // 调用run方法
        c.run();
    }
}
输出结果：
    小猫在墙头走~~~
```

此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。

抽象类的特点：

1. 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。
2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。抽象类的构造方法不能定义成私有（子类构造方法会调用父类构造方法）
3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
4. 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。
5. 抽象类不能使用final修饰，final修饰的类不能被继承

## 2.4 transient瞬态关键字

transient关键字：瞬态关键字。被transient 修饰的成员变量不能被序列化的，但是它却没有static的作用，只是能够避免序列化

一个对象要想要序列化，必须要满足两个条件：

* 该类必须实现`java.io.Serializable`接口，`Serializable`是一个标记接口，不实现此接口的类将不会使任何状态序列化或者反序列化，会抛出`NotSerializableException`。

* 该类的所有竖向必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用`transient`关键字修饰。

  `static`关键字：静态关键字。静态关键优先于非静态加载到内存中（静态优先于对象进入到内存中），被static 修饰的成员变量不能被序列化的，序列化的都是对象。

  `transient`关键字：瞬态关键字。被`transient` 修饰的成员变量不能被序列化的，但是它却没有`static`的作用，只是能够避免序列化

```java
public class Demo01ObjectOutputStream {
    public static void main(String[] args) throws IOException {
        // 1.创建ObjcetOutputStream对象，构造方法中传递字节输出流
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("10_IO\\oos.txt"));
        // 2.使用ObjectOutputStream对象中的方法writeObject，把对象写入到文件中
        oos.writeObject(new Person("小仙女", 19));
        // 3.释放资源
        oos.close();
    }
}
```

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person implements Serializable {
    private String name;
    private int age;
}
```

# 第三章 接口

接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。

接口的定义，它与定义类方式相似，但是使用 `interface` 关键字。它也会被编译成`.class`文件，但一定要明确它并不是类，而是另外一种引用数据类型。

> 引用数据类型：数组，类，接口。

接口的使用，它不能创建对象，但是可以被实现（ `implements` ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。

```java
public interface 接口名称 {
    // 抽象方法
    // 默认方法
    // 静态方法
    // 私有方法
}
```

* **抽象方法**
  使用 `abstract` 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。

  ```java
  public interface InterFaceName {
      public abstract void method();
  }
  ```

* **默认方法**
  使用 `default` 修饰，不可省略，供子类调用或者子类重写。

  ```java
  public interface InterFaceName {
      public default void method() {
          // 执行语句
      }
  }
  ```

* **静态方法**
  使用 `static` 修饰，供接口直接调用。

  ```java
  public interface InterFaceName {
      public static void method2() {
          // 执行语句
      }
  }
  ```

* **私有方法**
  使用 `private` 修饰，供接口中的默认方法或者静态方法调用。

  ```java
  public interface InterFaceName {
      private void method() {
          // 执行语句
      }
  }
  ```

## 3.1 基本的实现

类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 `implements` 关键字。

非抽象子类实现接口：

1. 必须重写接口中所有抽象方法。
2. 继承了接口的默认方法，即可以直接调用，也可以重写。

```java
class 类名 implements 接口名 {
    // 重写接口中抽象方法【必须】
    // 重写接口中默认方法【可选】
}
```

**抽象方法使用**

必须全部实现，代码如下：

```java
public interface LiveAble {
    // 定义抽象方法
    public abstract void eat();
    public abstract void sleep();
}
```

```java
public class Animal implements LiveAble {
    @Override
    public void eat() {
        System.out.println("吃东西");
    }
    @Override
    public void sleep() {
        System.out.println("晚上睡");
    }
}
```

**默认方法的使用**

可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。

1. 继承默认方法，代码如下：

   ```java
   public interface LiveAble {
       public default void fly(){
           System.out.println("天上飞");
       }
   }
   ```

   ```java
   public class Animal implements LiveAble {
       // 继承，什么都不用写，直接调用
   }
   ```

2. 重写默认方法，代码如下：

   ```java
   public interface LiveAble {
       public default void fly(){
           System.out.println("天上飞");
       }
   }
   ```

   ```java
   public class Animal implements LiveAble {
       @Override
       public void fly() {
           System.out.println("自由自在的飞");
       }
   }
   ```

**静态方法的使用**

静态与`.class` 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用，代码如下：

```java
public interface LiveAble {
    public static void run(){
        System.out.println("跑起来~~~");
    }
}
```

```java
public class Animal implements LiveAble {
    // 无法重写静态方法
}
```

```java
public class InterfaceDemo {
    public static void main(String[] args) {
        // Animal.run(); // 【错误】无法继承方法,也无法调用
        LiveAble.run(); //
    }
}
```

**私有方法的使用**

- 私有方法：只有默认方法可以调用。
- 私有静态方法：默认方法和静态方法可以调用。

如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。

```java
public interface LiveAble {
    default void func(){
        func1();
        func2();
    }
    private void func1(){
        System.out.println("跑起来~~~");
    }
    private void func2(){
        System.out.println("跑起来~~~");
    }
}
```

## 3.2 接口的多实现

之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。

```java
class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... {
    // 重写接口中抽象方法【必须】
    // 重写接口中默认方法【不重名时可选】
}
```

**抽象方法**

接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。代码如下：

```java
interface A {
    public abstract void showA();
    public abstract void show();
}
interface B {
    public abstract void showB();
    public abstract void show();
}

```

```java
public class C implements A,B{
    @Override
    public void showA() {
        System.out.println("showA");
    }
    @Override
    public void showB() {
        System.out.println("showB");
    }
    @Override
    public void show() {
        System.out.println("show");
    }
}
```

**默认方法**

接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。代码如下：

```java
interface A {
    public default void methodA(){}
    public default void method(){}
}
interface B {
    public default void methodB(){}
    public default void method(){}
}
```

```java
public class C implements A,B{
    @Override
    public void method() {
        System.out.println("method");
    }
}
```

**静态方法**

接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。

## 3.3 接口多实现优先级

当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。代码如下：

```java
interface A {
    public default void methodA(){
        System.out.println("AAAAAAAAAAAA");
    }
}
```

```java
class D {
    public void methodA(){
        System.out.println("DDDDDDDDDDDD");
    }
}
```

```java
class C extends D implements A {
    // 未重写methodA方法
}
```

```java
public class Test {
    public static void main(String[] args) {
        C c = new C();
        c.methodA();
    }
}
```

## 3.4 接口多继承

一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 `extends` 关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。代码如下：

```java
interface A {
    public default void method(){
        System.out.println("AAAAAAAAAAAAAAAAAAA");
    }
}
interface B {
    public default void method(){
        System.out.println("BBBBBBBBBBBBBBBBBBB");
    }
}
```

```java
interface D extends A,B{
    @Override
    public default void method() {
        System.out.println("DDDDDDDDDDDDDD");
    }
}
```

- 子接口重写默认方法时，`default`关键字可以保留。
- 子类重写默认方法时，`default`关键字不可以保留。

## 3.5 接口默认方法

我们通常所说的接口的作用是用于定义一套标准、约束、规范等，接口中的方法只声明方法的签名，不提供相应的方法体，方法体由对应的实现类去实现。

在JDK1.8中打破了这样的认识，接口中的方法可以有方法体，但需要关键字static或者default来修饰。使用`static`来修饰的称之为静态方法，静态方法通过接口名来调用。使用`default`来修饰的称之为默认方法，默认方法通过实例对象来调用。

静态方法和默认方法都有自己的方法体，用于提供一套默认的实现，这样子类对于该方法就不需要强制来实现，可以选择使用默认的实现，也可以重写自己的实现。

当为接口扩展方法时，只需要提供该方法的默认实现即可，至于对应的实现类可以重写也可以使用默认的实现，这样所有的实现类不会报语法错误：Xxx不是抽象的, 并且未覆盖Yxx中的抽象方法。

```java
public interface Hello {

    // 使用abstract修饰不修饰都行
    void sayHi();

    static void sayHello(){
        System.out.println("static method: say hello");
    }

    default void sayByebye(){
        System.out.println("default mehtod: say byebye");
    }
}
```

```java
public class HelloImpl implements Hello {
    @Override
    public void sayHi() {
        System.out.println("normal method: say hi");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        HelloImpl helloImpl = new HelloImpl();
        // 对于abstract抽象方法通过实例对象来调用
        helloImpl.sayHi();
        // default方法只能通过实例对象来调用
        helloImpl.sayByebye();
        // 静态方法通过 接口名.方法名() 来调用
        Hello.sayHello();

        // 接口是不允许new的，如果使用new后面必须跟上一对花括号用于实现抽象方法， 这种方式被称为匿名内部类，匿名内部类是一种没有名称的实现类
        // 匿名内部类的好处：不用再单独声明一个类，缺点：由于没有名字，不能重复使用，只能使用一次
        new IHello() {
            @Override
            public void sayHi() {
                System.out.println("normal method: say hi");
            }
        }.sayHi();
    }
}
```

```html
<!--
    normal method: say hi
    default mehtod: say byebye
    static method: say hello
    normal method: say hi
-->
```

## 3.6 接口特点

- 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。
- 接口中，没有构造方法，不能创建对象。
- 接口中，没有静态代码块。
- 接口中没有构造器，不能被实例化
- 接口只能继承接口，不能继承类，接口支持多继承
- 接口中的定义的成员变量，默认是`public static final`修饰的静态常量
- 接口中定义的方法，默认是`public abstract`修饰的抽象方法
- 接口中定义的内部类，默认是`public static`修饰的静态内部类

## 3.7 抽象类和接口的区别

相同点：

1. 抽象类和接口都不能被实例化
2. 抽象类和接口都可以定义抽象方法，子类/实现类必须覆写这些抽象方法

不同点：

1. 抽象类有构造方法，接口没有构造方法。
2. 抽象类可以包含普通方法，接口中只能是`public abstract`修饰抽象方法（Java8之后可以）
3. 抽象类只能单继承，接口可以多继承
4. 抽象类可以定义各种类型的成员变量，接口中只能是`public static final`修饰的静态常量

# 第四章 枚举

枚举就是要让某个类型的变量的取值只能为若干个固定值中的一个，否则，编译器就会报错。枚举可以让编译器在编译时就可以控制源程序中填写的非法值，普通变量的方式在开发阶段无法实现这一目标。

`enum` 的全称为 enumeration， 是 JDK 1.5 中引入的新特性。在Java中，被 `enum` 关键字修饰的类型就是枚举类型。形式如下：

```java
enum Color { RED, GREEN, BLUE }
```

如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加。

```java
enum Color { RED, GREEN, BLUE }
enum Color { RED, GREEN, BLUE, }
enum Color { RED, GREEN, BLUE; }
```

如果枚举不添加任何方法，枚举值默认为从0开始的有序数值。以 Color 枚举类型举例，它的枚举常量依次为 `RED：0，GREEN：1，BLUE：2`。

- 枚举的好处：可以将常量组织起来，统一进行管理。在编译时期就会发现错误，表明值不符合，减少了运行时期的错误。
- 枚举的典型应用场景：错误码、状态机等。

## 4.1 枚举本质

尽管 `enum` 看起来像是一种新的数据类型，事实上，enum是一种受限制的类，并且具有自己的方法。创建`enum`时，编译器会为你生成一个相关的类，这个类继承自 `java.lang.Enum`。

`java.lang.Enum`类声明如下：

```java
public abstract class Enum<E extends Enum<E>> 
        implements Comparable<E>, Serializable { ... }
```

## 4.2 枚举的方法

构造器方法：

1. 构造器只是在构造枚举值的时候被调用。

2. 构造器只有私有`private`，绝不允许有`public`构造器。这样可以保证外部代码无法重新构造枚举类的实例。因为枚举值是`public static final`的常量，但是枚举类的方法和数据域是可以被外部访问的。

3. 构造器可以有多个，调用哪个即初始化相应的值。

静态方法：

1. `valueOf(String e)`：转为对应的枚举对象，即将字符串转为对象

2. `values()`：获取所有的枚举对象元素

提供了一些基本方法：

- `getDeclaringClass()`：返回实例所属的 enum 类型。
- `equals()` ：判断是否为同一个对象。
- `String toString()`：返回枚举量的名称
- `int ordinal()`：返回枚举值在枚举类中的顺序，按定义的顺序排，默认第一个是0
- `Class getClass()`：获取对应的类名
- `String name()`：返回此枚举常量的名称，在其枚举声明中对其进行声明。

可以使用 `==` 来比较`enum`实例。此外，`java.lang.Enum`实现了`Comparable`和 `Serializable` 接口，所以也提供 `compareTo()` 方法。

```java
public class EnumMethodDemo {
    
    enum Color {RED, GREEN, BLUE;}
    enum Size {BIG, MIDDLE, SMALL;}
    
    public static void main(String args[]) {
        System.out.println("=========== Print all Color ===========");
        for (Color c : Color.values()) {
            System.out.println(c + " ordinal: " + c.ordinal());
        }
        System.out.println("=========== Print all Size ===========");
        for (Size s : Size.values()) {
            System.out.println(s + " ordinal: " + s.ordinal());
        }

        Color green = Color.GREEN;
        System.out.println("green name(): " + green.name());
        System.out.println("green getDeclaringClass(): " + green.getDeclaringClass());
        System.out.println("green hashCode(): " + green.hashCode());
        System.out.println("green compareTo Color.GREEN: " + green.compareTo(Color.GREEN));
        System.out.println("green equals Color.GREEN: " + green.equals(Color.GREEN));
        System.out.println("green equals Size.MIDDLE: " + green.equals(Size.MIDDLE));
        System.out.println("green equals 1: " + green.equals(1));
        System.out.format("green == Color.BLUE: %b\n", green == Color.BLUE);
    }
}
```

```yaml
=========== Print all Color ===========
RED ordinal: 0
GREEN ordinal: 1
BLUE ordinal: 2
=========== Print all Size ===========
BIG ordinal: 0
MIDDLE ordinal: 1
SMALL ordinal: 2
green name(): GREEN
green getDeclaringClass(): class org.zp.javase.enumeration.EnumDemo$Color
green hashCode(): 460141958
green compareTo Color.GREEN: 0
green equals Color.GREEN: true
green equals Size.MIDDLE: false
green equals 1: false
green == Color.BLUE: false
```

## 4.3 枚举的特性

枚举的特性，归结起来就是一句话：**除了不能继承，基本上可以将 `enum` 看做一个常规的类。**

但是这句话需要拆分去理解，让我们细细道来。

* 枚举不允许使用`=`为枚举常量赋值，但是可以添加普通方法、静态方法、抽象方法、构造方法来赋值
* 枚举可以实现接口
* 枚举不可以继承

**枚举添加方法赋值**

在前面提到了，枚举值默认为从0开始的有序数值 。那么问题来了：如何为枚举显示的赋值。

在C/C++语言中的enum，可以用赋值符号`=`显示的为枚举常量赋值；但是很遗憾，Java 语法中却不允许使用赋值符号 `=` 为枚举常量赋值。Java 虽然不能直接为实例赋值，但是它有更优秀的解决方案：为 enum 添加方法来间接实现显示赋值。

创建 `enum` 时，可以为其添加多种方法，甚至可以为其添加构造方法。

> 如果要为`enum`定义方法，那么必须在`enum`的最后一个实例尾部添加一个分号。此外，在`enum`中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。

```java
public enum ErrorCode {
    OK(0) {
        public String getDescription() {
            return "成功";
        }
    },
    ERROR_A(100) {
        public String getDescription() {
            return "错误A";
        }
    },
    ERROR_B(200) {
        public String getDescription() {
            return "错误B";
        }
    };

    private int code;

    // 构造方法：enum的构造方法只能被声明为private权限或不声明权限
    private ErrorCode(int number) { // 构造方法
        this.code = number;
    }
    
    public int getCode() { // 普通方法
        return code;
    } // 普通方法
    
    public abstract String getDescription(); // 抽象方法
    
    public static void main(String args[]) { // 静态方法
        for (ErrorCode s : ErrorCode.values()) {
            System.out.println("code: " + s.getCode() + ", description: " + s.getDescription());
        }
    }
}
```

也可以看看下面的这个：

```java
public enum ErrorCodeEn {
    OK(0, "成功"),
    ERROR_A(100, "错误A"),
    ERROR_B(200, "错误B");

    ErrorCodeEn(int number, String description) {
        this.code = number;
        this.description = description;
    }
    
    private int code;
    private String description;
    public int getCode() {
        return code;
    }
    public String getDescription() {
        return description;
    }
    
    public static void main(String args[]) { // 静态方法
        for (ErrorCodeEn s : ErrorCodeEn.values()) {
            System.out.println("code: " + s.getCode() + ", description: " + s.getDescription());
        }
    }
}
```

**枚举可以实现接口**

`enum` 可以像一般类一样实现接口。实现错误码枚举类，通过实现接口，可以约束它的方法。

```java
public interface INumberEnum {
    int getCode();
    String getDescription();
}

public enum ErrorCodeEn2 implements INumberEnum {
    OK(0, "成功"),
    ERROR_A(100, "错误A"),
    ERROR_B(200, "错误B");

    ErrorCodeEn2(int number, String description) {
        this.code = number;
        this.description = description;
    }

    private int code;
    private String description;

    @Override
    public int getCode() {
        return code;
    }

    @Override
    public String getDescription() {
        return description;
    }
}
```

**枚举不可以继承**

`enum` 不可以继承另外一个类，当然，也不能继承另一个 `enum` 。

因为 `enum` 实际上都继承自 `java.lang.Enum` 类，而 Java 不支持多重继承，所以 `enum` 不能再继承其他类，当然也不能继承另一个 `enum`。

## 4.4 枚举的应用场景

- 组织常量
- switch状态机
- 组织枚举
- 策略枚举

**组织常量**

在JDK1.5 之前，在Java中定义常量都是`public static final TYPE a;` 这样的形式。有了枚举，可以将有关联关系的常量组织起来，使代码更加易读、安全，并且还可以使用枚举提供的方法。

**switch 状态机**

我们经常使用`switch`语句来写状态机。JDK7以后，`switch`已经支持 `int`、`char`、`String`、`enum` 类型的参数。这几种类型的参数比较起来，使用枚举的`switch`代码更具有可读性。

```java
enum Signal {RED, YELLOW, GREEN}

public static String getTrafficInstruct(Signal signal) {
    String instruct = "信号灯故障";
    switch (signal) {
        case RED:
            instruct = "红灯停";
            break;
        case YELLOW:
            instruct = "黄灯请注意";
            break;
        case GREEN:
            instruct = "绿灯行";
            break;
        default:
            break;
    }
    return instruct;
}
```

**组织枚举**

可以将类型相近的枚举通过接口或类组织起来。但是一般用接口方式进行组织。

Java接口在编译时会自动为`enum`类型加上`public static`修饰符；Java类在编译时会自动为 `enum` 类型加上`static`修饰符。没错，在类中组织 `enum`，如果你不给它修饰为 `public`，那么只能在本包中进行访问。

```java
public interface Plant {
    enum Vegetable implements INumberEnum {
        POTATO(0, "土豆"),
        TOMATO(0, "西红柿");

        Vegetable(int number, String description) {
            this.code = number;
            this.description = description;
        }

        private int code;
        private String description;

        @Override
        public int getCode() {
            return 0;
        }

        @Override
        public String getDescription() {
            return null;
        }
    }

    enum Fruit implements INumberEnum {
        APPLE(0, "苹果"),
        ORANGE(0, "桔子"),
        BANANA(0, "香蕉");

        Fruit(int number, String description) {
            this.code = number;
            this.description = description;
        }

        private int code;
        private String description;

        @Override
        public int getCode() {
            return 0;
        }

        @Override
        public String getDescription() {
            return null;
        }
    }
}
```

**策略枚举**

《EffectiveJava》中展示了一种策略枚举。这种枚举通过枚举嵌套枚举的方式，将枚举常量分类处理。这种做法虽然没有switch语句简洁，但是更加安全、灵活。

```java
enum PayrollDay {
    MONDAY(PayType.WEEKDAY), TUESDAY(PayType.WEEKDAY), WEDNESDAY(PayType.WEEKDAY),      
    THURSDAY(PayType.WEEKDAY), FRIDAY(PayType.WEEKDAY), SATURDAY(PayType.WEEKEND), 
    SUNDAY(PayType.WEEKEND);

    private final PayType payType;

    PayrollDay(PayType payType) {
        this.payType = payType;
    }

    double pay(double hoursWorked, double payRate) {
        return payType.pay(hoursWorked, payRate);
    }

    // 策略枚举
    private enum PayType {
        WEEKDAY {
            double overtimePay(double hours, double payRate) {
                return hours <= HOURS_PER_SHIFT ? 0 : (hours - HOURS_PER_SHIFT) * payRate / 2;
            }
        },
        WEEKEND {
            double overtimePay(double hours, double payRate) {
                return hours * payRate / 2;
            }
        };
        private static final int HOURS_PER_SHIFT = 8;

        abstract double overtimePay(double hrs, double payRate);

        double pay(double hoursWorked, double payRate) {
            double basePay = hoursWorked * payRate;
            return basePay + overtimePay(hoursWorked, payRate);
        }
    }
}
```

```java
public static void main(String[] args) {
    System.out.println("时薪100的人在周五工作8小时的收入：" + PayrollDay.FRIDAY.pay(8.0, 100));
    System.out.println("时薪100的人在周六工作8小时的收入：" + PayrollDay.SATURDAY.pay(8.0, 100));
}
```

## 4.5 EnumSet和EnumMap

Java 中提供了两个方便操作enum的工具类——`EnumSet` 和 `EnumMap`。

`EnumSet` 是枚举类型的高性能 `Set` 实现。它要求放入它的枚举常量必须属于同一枚举类型。

```java
// EnumSet的使用
System.out.println("EnumSet展示");
EnumSet<ErrorCodeEn> errSet = EnumSet.allOf(ErrorCodeEn.class);
for (ErrorCodeEn e : errSet) {
    System.out.println(e.name() + " : " + e.ordinal());
}
```

`EnumMap` 是专门为枚举类型量身定做的 `Map` 实现。虽然使用其它的 `Map` 实现（如`HashMap`）也能完成枚举类型实例到值得映射，但是使用 `EnumMap` 会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 `EnumMap` 使用数组来存放与枚举类型对应的值。这使得 `EnumMap` 的效率非常高。

```java
// EnumMap的使用
System.out.println("EnumMap展示");
EnumMap<StateMachine.Signal, String> errMap = new EnumMap(StateMachine.Signal.class);
errMap.put(StateMachine.Signal.RED, "红灯");
errMap.put(StateMachine.Signal.YELLOW, "黄灯");
errMap.put(StateMachine.Signal.GREEN, "绿灯");
for (Iterator<Map.Entry<StateMachine.Signal, String>> iter = errMap.entrySet().iterator(); iter.hasNext();) {
    Map.Entry<StateMachine.Signal, String> entry = iter.next();
    System.out.println(entry.getKey().name() + " : " + entry.getValue());
}
```

## 4.6 小结

1. 匿名内部类比较常用
2. 类的方法返回的类型可以是本类的类型
3. 类中可定义静态常量，常量的结果就是自己这个类型的实例对象
4. 枚举只有一个成员时，就可以作为一种单例的实现方式。

# 第五章 引用类型用法

实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步
去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类
型也是可以的。

## 5.1 类作为成员变量

在定义一个类Role（游戏角色）时，代码如下：

```java
class Role {
    int id; // 角色id
    int blood; // 生命值
    String name; // 角色名称
}
```

使用 int 类型表示 角色id和生命值，使用 String 类型表示姓名。此时， String 本身就是引用类型，由于使用的方式类似常量，所以往往忽略了它是引用类型的存在。如果我们继续丰富这个类的定义，给 Role 增加武器，穿戴装备等属性，我们将如何编写呢？

定义武器类，将增加攻击能力：

```java
class Weapon {
    String name； // 武器名称
    int hurt； // 伤害值
}
```

定义穿戴盔甲类，将增加防御能力，也就是提升生命值：

```java
class Armour {
    String name；// 装备名称
    int protect；// 防御值
}
```

定义角色类：

```java
class Role {
    int id;
    int blood;
    String name;
    // 添加武器属性
    Weapon wp;
    // 添加盔甲属性
    Armour ar;
    // 提供get/set方法
    public Weapon getWp() {
        return wp;
    }
    public void setWeapon(Weapon wp) {
        this.wp = wp;
    }
    public Armour getArmour() {
        return ar;
    }
    public void setArmour(Armour ar) {
        this.ar = ar;
    }
    // 攻击方法
    public void attack(){
        System.out.println("使用"+ wp.getName() +", 造成"+wp.getHurt()+"点伤害");
    }
    // 穿戴盔甲
    public void wear(){
        // 增加防御,就是增加blood值
        this.blood += ar.getProtect();
        System.out.println("穿上"+ar.getName()+", 生命值增加"+ar.getProtect());
    }
}
```

测试类：

```java
public class Test {
    public static void main(String[] args) {
        // 创建Weapon 对象
        Weapon wp = new Weapon("屠龙刀" , 999999);
        // 创建Armour 对象
        Armour ar = new Armour("麒麟甲",10000);
        // 创建Role 对象
        Role r = new Role();
        // 设置武器属性
        r.setWeapon(wp);
        // 设置盔甲属性
        r.setArmour(ar);
        // 攻击
        r.attack();
        // 穿戴盔甲
        r.wear();
    }
}
输出结果:
	使用屠龙刀,造成999999点伤害
    穿上麒麟甲 ,生命值增加10000
```

> 类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。

## 5.2 接口作为成员变量

接口是对方法的封装，对应游戏当中，可以看作是扩展游戏角色的技能。所以，如果想扩展更强大技能，我们在Role 中，可以增加接口作为成员变量，来设置不同的技能。

```java
// 法术攻击
public interface FaShuSkill {
    public abstract void faShuAttack();
}
```

```java
public class Role {
    FaShuSkill fs;
    public void setFaShuSkill(FaShuSkill fs) {
        this.fs = fs;
    }
    // 法术攻击
    public void faShuSkillAttack(){
        System.out.print("发动法术攻击:");
        fs.faShuAttack();
        System.out.println("攻击完毕");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 创建游戏角色
        Role role = new Role();
        // 设置角色法术技能
        role.setFaShuSkill(new FaShuSkill() {
            @Override
            public void faShuAttack() {
                System.out.println("纵横天下");
            }
        });
        // 发动法术攻击
        role.faShuSkillAttack();
        // 更换技能
        role.setFaShuSkill(new FaShuSkill() {
            @Override
            public void faShuAttack() {
                System.out.println("逆转乾坤");
            }
        });
        // 发动法术攻击
        role.faShuSkillAttack();
    }
}
输出结果:
	发动法术攻击:纵横天下
    攻击完毕
    发动法术攻击:逆转乾坤
    攻击完毕
```

> 我们使用一个接口，作为成员变量，以便随时更换技能，这样的设计更为灵活，增强了程序的扩展性。 接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。

## 5.3 接口作为方法参数和返回值

当接口作为方法的参数时,需要传递什么呢？当接口作为方法的返回值类型时，需要返回什么呢？对，其实都是它的子类对象。 ArrayList 类我们并不陌生，查看API我们发现，实际上，它是 java.util.List 接口的实现类。所以，当我们看见 List 接口作为参数或者返回值类型时，当然可以将 ArrayList 的对象进行传递或返回。

请观察如下方法：获取某集合中所有的偶数。

```java
public static List<Integer> getEvenNum(List<Integer> list) {
    // 创建保存偶数的集合
    ArrayList<Integer> evenList = new ArrayList<>();
    // 遍历集合list,判断元素为偶数,就添加到evenList中
    for (int i = 0; i < list.size(); i++) {
        Integer integer = list.get(i);
        if (integer % 2 == 0) {
            evenList.add(integer);
        }
    }
    /*
        返回偶数集合
        因为getEvenNum方法的返回值类型是List,而ArrayList是List的子类,
        所以evenList可以返回
    */
    return evenList;
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 创建ArrayList集合,并添加数字
        ArrayList<Integer> srcList = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            srcList.add(i);
        }
        /*
            获取偶数集合
            因为getEvenNum方法的参数是List,而ArrayList是List的子类,
            所以srcList可以传递
        */
        List list = getEvenNum(srcList);
        System.out.println(list);
    }
}
```

> 接口作为参数时，传递它的子类对象。 接口作为返回值类型时，返回它的子类对象。

# 第六章 JDK版本特性

![](..\图片\1-00【Java基础】\12-1版本特性.png)
