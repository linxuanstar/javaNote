# 第一章 数组

数组：Array，是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。

简单的说,采用该结构的集合，对元素的存取有如下的特点：

* 查找元素快：通过索引，可以快速访问指定位置的元素

* 增删元素慢：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。

创建方式如下：

```java
// 动态初始化：初始化时由程序员只指定数组长度，由系统为数组元素分配初始值
char c1[] = new char[5];
// 静态初始化： 初始化时由程序员显示置顶每个数组的初始值，由系统决定数组长度
char c2[] = new char[]{'E','D','U','Y','U'};
char c3[] = {'E','D','U','Y','U'};
```

特点如下：

- 内存地址连续；
- 增删操作带来更大的性能消耗；
- 可以通过下标的成员访问，下标访问的性能高；

返回空数组：

```java
return Arrays.asList(); // 返回空的List集合
```

```java
// 将list转为int数组
return arrayList.stream().mapToInt(Integer::intValue).toArray();
```

判断数组为空：

```java
if (strs == null || strs.length == 0) {
    return "";
}
```

# 第二章 栈和队列

常用方法：

* 栈：`push pop peek`
* 队列：`offer poll peek`返回false、`add remove element`抛异常(最好不要使用)

## 2.1 栈stack

栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。

栈`stack`，又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。采用该结构的集合，对元素的存取有如下的特点：先进后出、栈的入口和出口的都是栈的顶端位置。

这里两个名词需要注意：

* 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。
* 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。

![](D:\Java\笔记\图片\6-04【数据结构和算法-数据结构】\1-堆栈.png)

`Stack`只有压栈和弹栈的操作。在Java中，我们用`Deque`可以实现`Stack`的功能。为什么Java的集合类没有单独的`Stack`接口呢？因为有个遗留类名字就叫`Stack`，出于兼容性考虑，所以没办法创建`Stack`接口，只能用`Deque`接口来“模拟”一个`Stack`了。

| 方法    | 作用               |
| ------- | ------------------ |
| push(E) | 把元素压栈         |
| pop()   | 取栈顶元素并且弹出 |
| peek()  | 取栈顶元素但不弹出 |

当我们把`Deque`作为`Stack`使用时，注意只调用`push()`/`pop()`/`peek()`方法，不要调用`addFirst()`/`removeFirst()`/`peekFirst()`方法，这样代码更加清晰。

```java
public static void main(String[] args) {
    Deque<String> stack = new LinkedList<>();

    // 压栈
    stack.push("第一个元素");
    stack.push("第二个元素");
    // 出栈并且弹出
    System.out.println(stack.pop()); // 第二个元素
    // 出栈不弹出
    System.out.println(stack.peek()); // 第一个元素
}
```

## 2.2 队列queue

队列（Queue）是实一种先进先出（FIFO：First In First Out）的有序表。

队列`queue`，简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。

简单的说，采用该结构的集合，对元素的存取有如下的特点：先进先出、队列的入口和出口各占一侧。

![](D:\Java\笔记\图片\6-04【数据结构和算法-数据结构】\1-2队列.png)

在Java的标准库中，队列接口`Queue`定义了以下几个方法：

| 方法                              | 作用                           |
| --------------------------------- | ------------------------------ |
| int size()                        | 获取队列长度                   |
| boolean add(E) / boolean offer(E) | 添加元素到队尾                 |
| E remove() / E poll()             | 获取队首元素并从队列中删除     |
| E element() / E peek()            | 获取队首元素但并不从队列中删除 |

对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：

|                    | throw Exception | 返回false或null    |
| :----------------- | :-------------- | ------------------ |
| 添加元素到队尾     | add(E e)        | boolean offer(E e) |
| 取队首元素并删除   | E remove()      | E poll()           |
| 取队首元素但不删除 | E element()     | E peek()           |

> 注意：不要把`null`添加到队列中，否则`poll()`方法返回`null`时，很难确定是取到了`null`元素还是队列为空。

> 队列下面又有：优先队列PriorityQueue、双端队列Deque。具体的可以看集合篇章。

# 第三章 链表

链表：linked list，由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。链表也是线性的顺序存储数据，只是在内存地址上不是连续的，每一个节点里存到下一个节点的地址(Pointer)。

> 刷算法题的时候记住：dummy哑结点、cur现在的节点（head节点复制给cur，让cur节点移动）

## 3.1 单链表

我们常说的链表结构有单向链表与双向链表，这里介绍的是单向链表。简单的说，采用该结构的集合，对元素的存取有如下的特点：

* 多个结点之间，通过地址进行连接。
* 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素
* 增删元素快：只需要修改连接下个元素的地址即可。

单链表的实现如下：

```java
/*
 *	定义节点
 *  链表由节点构成
 */
public class ListNode<E> {
    private E e;   				//数据data
    private ListNode<E> next; 	 //指向下一个节点

    public ListNode() {
    }

    public ListNode(E e) {
        this.e = e;
    }

    public ListNode<E> getNext() {
        return next;
    }

    public void setNext(ListNode<E> next) {
        this.next = next;
    }

    public E getE() {
        return e;
    }

    public void setE(E e) {
        this.e = e;
    }
}
```

```java
/*
 * 定义实现类LinkedList*　实现链表的基本功能：增删改查
 */
public class LinkedList<E> {
    // 声明头节点尾节点
    private ListNode<E> head;
    private ListNode<E> last;
    // 链表的大小
    private int size;

    /*
     * 构造函数，构建一个链表
     */
    public LinkedList() {
        head = new ListNode<E>();
        last = head;
    }

    /*
     * 返回单链表中存储的元素总数
     */
    public int size() {
        return size;
    }

    /*
     * 获取指定索引位置的节点对象
     */
    public ListNode<E> get(int index) {
        if (index < 0 || index > size - 1)
            return null;
        ListNode<E> node = head.getNext(); // 将头结点的下一个节点赋给Node
        for (int i = 0; i < index; i++) {
            node = node.getNext(); // 获取node的下一个节点
        }
        return node;
    }

    /*
     * 获取指定索引位置的数据
     */
    public E getValue(int index) {
        ListNode<E> node = get(index);
        return node.getE();
    }

    /*
     * 增加元素
     */
    public void add(E e) {
        ListNode<E> node = new ListNode<E>(e); // 以e实例化一个节点
        last.setNext(node); // 往尾节点后追加节点
        last = node; // 该节点设为最后一个节点
        size++;
    }

    /*
     * 指定位置插入元素,返回插入的节点数据
     */
    public E add(int index, E e) {
        if (index < 0 || index > size - 1)
            return null;
        ListNode<E> node = new ListNode<E>(e); // 实例化一个节点
        // 找到插入的原节点
        ListNode<E> oldNode = get(index);
        if (index == 0) {// 当索引为0时
            head.setNext(node);
        } else {
            // 找到插入节点的上一个
            ListNode<E> bNode = get(index - 1);
            bNode.setNext(node);
        }
        node.setNext(oldNode);
        size++;
        return oldNode.getE();
    }

    /*
     * 删除指定的节点e,并返回删除节点的数据
     */
    public E delete(int index) {
        if (index < 0 || index > size - 1)
            return null;
        if (index == 0) {// 当索引为1，令头结点的下一个节点为头结点
            ListNode<E> node = head.getNext();
            head.setNext(node.getNext());
        }
        // 获取要删除节点的前一个节点
        ListNode<E> bNode = get(index - 1);
        // 获取要删除的节点
        ListNode<E> Node = bNode.getNext();
        // 获取要删除节点的下一个节点
        ListNode<E> nNode = Node.getNext();
        // 删除该节点
        bNode.setNext(nNode);
        // 清除Node的下一个节点
        Node.setNext(null);
        size--;
        return Node.getE();// 返回节点中的数据域
    }

    /*
     * 修改指定位置的数据域并返回修改后的数据
     */
    public E set(int index, E e) {
        if (index < 0 || index > size - 1)
            return null;
        // 获取指定位置的原节点
        ListNode<E> node = get(index);
        node.setE(e);
        return node.getE();
    }
}
```

## 3.2 双向链表

双向链表是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。

![](D:\Java\笔记\图片\6-04【数据结构和算法-数据结构】\2-1双链表.png)

```java
static final class Node {
    // 前一个节点
    volatile Node prev;
    // 后一个节点
    volatile Node next;
    // 链表节点存储的具体数据
    volatile Thread thread;
}
```

# 第五章 树

树的常用术语如下：

* 节点：由数据元素及其若干分支组成
* 节点的度：结点分支的个数
* 树的度：选取所有结点中最大的度
* 叶子结点：度为0的结点就是叶子结点，它位于树最深层，并且树只要非空，就一定存在叶子结点
* 分支节点：度大于0的结点为分支结点，显然除了叶子结点之外的结点都为分支结点
* 父节点和子结点：一个结点若干分支下的结点都为该结点的子结点(孩子)，该结点称为子结点的父节点
* 路径：从一个结点到另一个结点之间的边和结点构成路径
* 层次：结点的层次有时也称为结点的深度，根结点的层次为0(有的地方规定为1)。自顶向下
* 高度：叶子结点的高度认为是0，向上高度加1。自下向顶
* 树的高度：树的高度就是根结点的高度
* 森林：森林就是彼此不相交的树的集合，树也可以看成是森林共有一个根结点后的结构

## 5.1 二叉树

二叉树：每个子节点只有两个节点的树，每个结点至多拥有两棵子树(即二叉树中不存在度大于2的结点)。二叉树的子树有左右之分，其次序不能任意颠倒。顶上的叫根结点，两边被称作“左子树”和“右子树”。

二叉树五种形态：

![](..\图片\6-04【数据结构和算法-数据结构】\3-1二叉树.png)

二叉树中的遍历规则有如下三种：

- 先序遍历：所谓的前序遍历就是先访问根节点，再访问左节点，最后访问右节点，即根-左-右遍历(前序)
- 中序遍历：所谓的中序遍历就是先访问左节点，再访问根节点，最后访问右节点，即左-根-右遍历
- 后序遍历：所谓的后序遍历就是先访问左节点，再访问右节点，最后访问根节点。即左-右-根遍历

二叉树又分为：完美二叉树，完全二叉树，完满二叉树

**完美二叉树**

完美二叉树：又称为满二叉树，除了叶子节点之外的每一个节点都有两个孩子节点，每层都被完全填充

![](..\图片\6-04【数据结构和算法-数据结构】\3-2完美二叉树.png)

**完全二叉树**

完全二叉树：除了最后一层之外的其他每一层都被完全填充，并且所有的节点都保持向左对齐

![](..\图片\6-04【数据结构和算法-数据结构】\3-3完全二叉树.png)

**完满二叉树**

## 5.2 堆/二叉堆

二叉堆在完全二叉树的基础上，增加了节点取值的限制条件，所以它的数据结构就是完全二叉树。可以分为大顶堆/最大堆，小顶堆/最小堆，而堆排序就是基于这种结构而产生的一种程序算法。

- 大顶堆/最大堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；

- 小顶堆/最小堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；

## 5.2 BST二叉查找树

二叉查找树（Binary Search Tree，BST）又名二叉搜索树，二叉排序树。具有下面这4个性质：

1. 如果左子树不空则左子树上所有结点的值均小于或等于该结点的值
2. 如果右子树不空则右子树上所有结点的值均大于或等于该结点的值
3. 左右子树也分别为二叉查找树。
4. 没有键值相等的节点。

等于的情况一般只出现在左子树或右子树中的某一侧，二叉查找树中没有重复的节点。中序遍历二叉查找树，就会得到一个从小到大的序列，所以它也被称为二叉排序树。

![](..\图片\6-04【数据结构和算法-数据结构】\3-4.png)

一个二叉查找树是由n个节点随机构成，所以对于某些情况，二叉查找树会退化成一个有n个节点的线性链。

## 5.4 AVL平衡二叉树

平衡二叉树又名AVL树，平衡二叉查找树，平衡二叉搜索树。

由前苏联的数学家 Adelse-Velskil 和 Landis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。常见的平衡树：AVL树、红黑树、Treap、伸展树、加权平衡树、2-3树、AA树、替罪羊树、节点大小平衡树。

平衡二叉树的特点：

- 可以是空树。
- 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。

假如一棵树的左右子树的高度之差超过1，如左子树的树高为2，右子树的树高为0，子树树高差的绝对值为2就打破了这个平衡。左右子树的高度差由平衡因子来记录。

每当我们向平衡二叉树插入或者删除一个节点的时候都有可能导致失衡，所以这时候就需要进行失衡调整。平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的。

- 平衡因子：左子树的高度减去右子树的高度。由平衡二叉树的定义可知，平衡因子的取值只可能为0、1、-1，分别对应着左右子树等高，左子树比较高，右子树比较高。

- 最小失衡子树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过1的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的，我们只需要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。


在图7中。2结点（左子树树高-右子树树高）的绝对值=2。同理，3结点的平衡因子也为2。此时同时存在了两棵不平衡子树，而以3为根的树是最小的不平衡子树。我们只要将其以3为中心，将最小不平衡树向左旋转，即可得到平衡二叉树，如图8。

![](..\图片\6-04【数据结构和算法-数据结构】\3-7.png)

我们使用连续的两个字母来表示平衡因子，以表示各种不同的情况。第一个字母表示最小不平衡子树根结点的平衡因子，第二个字母表示最小不平衡子树较高子树的根结点的平衡因子。使用L表示左子树较高，R表示右子树较高，E表示左右子树等高。

下面我们将对所有的失衡情况进行讨论。大致分为两大类，一左子树过高，二右子树过高。左子树过高的情况又有LL型、LE型、LR型，右子树过高的情况有RR型、RL型。

**左子树过高LL型**

在LL型的不平衡树中，我们首先找到最小不平衡子树，再以其根结点向右旋转。向右旋转后，相当于右边的子树树高增加了1，而左边的子树树高降低了1，而原本的树高之差为2，那么就能够将根的平衡因子就化为0。旋转之后：原来根结点的左孩子作为新的根结点。

1. 将2作为根结点
2. 将3作为2的右孩子
3. 将2的右孩子作为3的左孩子（维护树的有序性，只是此处为NULL而已）

![](..\图片\6-04【数据结构和算法-数据结构】\3-8.png)

 **左子树过高LE型**

插入的时候，是不会出现LE的这种情况的。只有在删除的时候才会出现。

![](D:\Java\笔记\图片\6-04【数据结构和算法-数据结构】\3-9.png)

假设这种情况存在：

* 假设我们刚插入的元素是1，那么原来的树已经不是平衡树。不可能。
* 假设我们刚插入的元素是3，那么原来的树也不是平衡树，也不可能。

所以在插入的时候，不会出现LE的这种情况的。会在删除的情况中出现这种情况。同理，不可能出现RE的情况。

**左子树过高LR型**

对于LR，要分为两步进行旋。旋转之后：原来根结点的左孩子的右孩子作为新的根结点。第一步是以较高子树的根为中心向左旋转，第二部是以原树的根向右旋转。

1. 将2的左子树作为1的右子树（维护树的有序性，只是此处为NULL而已）
2. 将1作为2的左子树
3. 将2作为3的左子树
4. 这时候就成为了左子树过高LL型不平衡树。
5. 将2作为根结点
6. 将3作为2的右孩子
7. 将2的右孩子作为3的左孩子（维护树的有序性，只是此处为NULL而已）

![](..\图片\6-04【数据结构和算法-数据结构】\3-10.png)

**右子树过高RR型**

旋转的步骤如下。旋转之后为：原来根结点的右孩子作为新的根结点。

1. 将2作为根结点
2. 将1作为2的左孩子
3. 将2的左孩子作为1的右孩子（维护树的有序性，只是此处为NULL而已）

![](..\图片\6-04【数据结构和算法-数据结构】\3-11.png)

**右子树过高RL型**

与LR型类似，我们需要进行两次旋转。旋转之后：原来根结点的右孩子的左孩子作为新的根结点。第一步是以较高子树的根为中心向右旋转，第二部是以原树的根向左旋转。

1. 将2作为1的右孩子
2. 将3作为2的右孩子

3. 将2的右孩子作为3的左孩子（维护树的有序性，只是此处为NULL而已）
4. 此时就成为了右子树过高RR型不平衡树。
5. 将2作为根结点
6. 将1作为2的左孩子
7. 将2的左孩子作为1的右孩子（维护树的有序性，只是此处为NULL而已）

![](..\图片\6-04【数据结构和算法-数据结构】\3-12.png)

**总结**

1. 在所有的不平衡情况中，都是按照“寻找最小不平衡树”->“寻找所属的不平衡类别”->“根据4种类别进行固定化程序的操作”。
2. LL、LR、RR、RL其实已经为我们提供了最后哪个结点作为新的根指明了方向。如LR型最后的根结点为原来的根的左孩子的右孩子，RL型最后的根结点为原来的根的右孩子的左孩子。
3. 维护平衡二叉树，最麻烦的地方在于平衡因子的维护。

## 5.2 R-B红黑树

红黑树（Red-Black Tree，R-B Tree）：它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。具有如下特性：

* 每个节点或者是黑色，或者是红色。
* 根节点是黑色**。**
* 每个叶子节点（NIL）是黑色。这里叶子节点，是指为空（NIL或NULL）的叶子节点。
* 任何相邻的两个节点不能同时为红色，也就是说每个红色节点的子节点都是黑色的。
* 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同。确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。

红黑树的特点：速度特别快，趋近平衡树，查找叶子元素最少和最多次数不多于二倍。

![](..\图片\6-04【数据结构和算法-数据结构】\3-13红黑树.png)





![](..\图片\6-04【数据结构和算法-数据结构】\3-6红黑树.png)

## 5.4 tire树/字典树

tire树又称字典树或前缀树，是一种有序的，用于统计排序和存储字符串的数据结构，它与二叉查找树不同，关键字不是直接保存在节点中，而是由节点在树中的位置决定。

每个节点都代表了一个字符，从第一层孩子节点到某个标记的节点代表了存储的字符串。一般情况下不是所有的节点都有对应的字符串，只有叶子节点和部分内部节点进行了特殊的标记，才存储字符串。

例如将这些字符串存储到字典树中，被标记为红色的节点代表存储了从根到该节点之间字符组成的字符串。

![](D:\Java\笔记\图片\6-04【数据结构和算法-数据结构】\3-5字典树.png)

一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，例如abc、abcd、abd都有相同的前缀ab，在字典树中它们有相同的祖先节点a和b。

trie树的最大优点就是利用字符串的公共前缀，来减少存储空间与查询时间，从而最大限度地减少无谓的字符串比较，是非常高效的字符串查找数据结构，查找和插入字符串都可达到 O（1） 算法复杂度。

## 5.2 B树

B树（Balanced-tree）：B树的英文名称为B-tree，译作B-树，因此B树就是B-树。B树是一种多叉路平衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针。

- 5阶的B树，每一个节点最多存储4个key，对应5个指针。
- 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。 
- 在B树中，非叶子节点和叶子节点都会存放数据。

![](..\图片\6-04【数据结构和算法-数据结构】\12-3.png)

## 5.3 B+树

B+ 树是 B 树的一种变体：

* B 树的所有节点既存放键也存放数据，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。
* B 树的叶子节点都是独立的，B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
* B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。

![](..\图片\6-04【数据结构和算法-数据结构】\12-4.png)

# 第六章 哈希表

哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。这种方法的基本思想是：首先在元素的关键字*k*和元素的存储位置*p*之间建立一个对应关系*f*，使得*p=f(k)*，*f*称为哈希函数。

创建哈希表时，把关键字为*k*的元素直接存入地址为*f(k)*的单元；以后当查找关键字为*k*的元素时，再利用哈希函数计算出该元素的存储位置*p=f(k)*，从而达到按关键字直接存取元素的目的。

当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，即 *k1*≠*k2* ，但 *H*（*k1*）*=H*（*k2*），这种现象称为**冲突，**此时称*k1*和*k2*为**同义词。**实际中，冲突是不可避免的，只能通过改进哈希函数的性能来减少冲突。

综上所述，哈希法主要包括以下两方面的内容：

1. 如何构造哈希函数
2. 如何处理冲突。

## 6.1 哈希函数的构造方法

构造哈希函数的原则是：①函数本身便于计算；②计算出来的地址分布均匀，即对任一关键字*k*，*f(k)* 对应不同地址的概率相等，目的是尽可能减少冲突。

下面介绍构造哈希函数常用的五种方法。

### 数字分析法

取关键字或关键字的某个线性函数值为哈希地址。即H(key)=key 或 H(key)=a*key+b  (a,b为常数)。

* 举例1：统计1-100岁的人口，其中年龄作为关键字，哈希函数取关键字自身。查找年龄25岁的人口有多少，则直接查表中第25项。

  | 地址 | 01          02         03   ...           25          26            27  ...   100 |
  | ---- | ------------------------------------------------------------ |
  | 年龄 | 1             2            3   ...            25          26           27   ...   .... |
  | 人数 | 3000    2000  .............             1050                 |
  | ...  |                                                              |

* 举例2：统计解放以后出生人口，其中年份作为关键字，哈希函数取关键字自身加一个常数H(key)=key+(-1948).查找1970年出生的人数，则直接查(1970-1948)=22项即可。

  | 地址 | 01          02         03   ...           22          23            24  ... |
  | ---- | ------------------------------------------------------------ |
  | 年份 | 1949     1950      1951   ...     1970                       |
  | 人数 | .............            15000                               |
  | ...  |                                                              |

### 平方取中法

取关键字平方后的中间几位为哈希地址。（较常用的一种）

* 举例：为BASIC源程序中的标识符键一个哈希表（假设BASIC语言允许的标识符为一个字母或者一个字母和一个数字两种情况，在计算机内可用两位八进制数表示字母和数字），假设表长为512，则可取关键字平方后的中间9位二进制数为哈希地址。（每3个二进制位可表示1位八进制位，即3个八进制位为9个二进制位）

  A ：01 （A的ASCII码值为65,65的八进制为101，取后两位表示关键字）

  B：02 （B的ASCII码值为66,66的八进制为102，取后两位表示关键字）

  ...

  Z：32（Z的ASCII码值为90,90的八进制为132，取后两位表示关键字）

  ...

  0：60（0的ASCII码值为48,48的八进制为60，取后两位表示关键字）

  ...

  

  9：71（9的ASCII码值为57,57的八进制为71，取后两位表示关键字）

  | 记录 | 关键字 | 关键字的平方      | 哈希地址（![2^{17}](https://private.codecogs.com/gif.latex?2%5E%7B17%7D)~![2^{9}](https://private.codecogs.com/gif.latex?2%5E%7B9%7D)） |
  | ---- | ------ | ----------------- | ------------------------------------------------------------ |
  | A    | 0100   | 0***\*010\****000 | 010                                                          |
  | I    | 1100   | 1***\*210\****000 | 210                                                          |
  | P1   | 2061   | 4***\*310\****541 | 310                                                          |
  | Q2   | 2162   | 4***\*741\****304 | 741                                                          |

### 分段叠加法

这种方法是按哈希表地址位数将关键字分成位数相等的几部分（最后一部分可以较短），然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。具体方法有**折叠法**与**移位法。**

移位法是将分割后的每部分低位对齐相加，折叠法是从一端向另一端沿分割界来回折叠（奇数段为正序，偶数段为倒序），然后将各段相加。

例如：*key=12360324711202065,*哈希表长度为*1000*，则应把关键字分成*3*位一段，在此舍去最低的两位*65*，分别进行移位叠加和折叠叠加，求得哈希地址为*105*和*907*，如图*8.24*所示。

![](D:\Java\笔记\图片\6-04【数据结构和算法-数据结构】\6-4分段叠加法.png)

### 除留余数法

取关键字为某个不大于哈希表表长m的数p除后所得余数为哈希地址（p为素数）

`H（key）=key  MOD  p`p<=m   （最简单，最常用）p的选取很重要

一般情况，p可以选取为质数或者不包含小于20的质因数的合数（合数指自然数中除了能被1和本身整除外，还能被其他数（0除外）整除的数）。

假设哈希表长为*m*，*p*为小于等于*m*的最大素数，则哈希函数为`h（k）=k % p` ，其中*%*为模*p*取余运算。

* 例如，已知待散列元素为（*18*，*75*，*60*，*43*，*54*，*90*，*46*），表长*m=10*，*p=7*，则有

  *h(18)=18 % 7=4  h(75)=75 % 7=5  h(60)=60 % 7=4*  

  *h(43)=43 % 7=1  h(54)=54 % 7=5  h(90)=90 % 7=6*  

  *h(46)=46 % 7=4*

  此时冲突较多。为减少冲突，可取较大的*m*值和*p*值，如*m=p=13*，结果如下：

  *h(18)=18 % 13=5  h(75)=75 % 13=10  h(60)=60 % 13=8*   

  *h(43)=43 % 13=4  h(54)=54 % 13=2  h(90)=90 % 13=12*  

  *h(46)=46 % 13=7*

### 伪随机数法

采用一个伪随机函数做哈希函数，即*`h(key)=random(key)`*。

在实际应用中，应根据具体情况，灵活采用不同的方法，并用实际数据测试它的性能，以便做出正确判定。通常应考虑以下五个因素 ：

* 计算哈希函数所需时间 （简单）。

* 关键字的长度。

* 哈希表大小。

* 关键字分布情况。

* 记录查找频率

## 6.2 处理哈希冲突的方法

虽然我们不希望发生冲突，但实际上发生冲突的可能性仍是存在的。

当关键字值域远大于哈希表的长度，而且事先并不知道关键字的具体取值时。冲突就难免会发 生。另外，当关键字的实际取值大于哈希表的长度时，而且表中已装满了记录，如果插入一个新记录，不仅发生冲突，而且还会发生溢出。

因此，处理冲突和溢出是 哈希技术中的两个重要问题。常用的解决冲突方法有以下几种：

### 开放定址法

用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。

>  注意：
>
> 1. 用开放定址法建立散列表时，建表前须将表中所有单元(更严格地说，是指单元中存储的关键字)置空。
> 2. 空单元的表示与具体的应用相关。

按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、线性补偿探测法、随机探测等 。

#### 线性探查法(Linear Probing)

该方法的基本思想是：将散列表T[0..m-1]看成是一个循环向量，若初始探查的地址为d(即h(key)=d)，则最长的探查序列为：`d，d+l，d+2，…，m-1，0，1，…，d-1`即:探查时从地址d开始，首先探查T[d]，然后依次探查T[d+1]，…，直到T[m-1]，此后又循环到T[0]，T[1]，…，直到探查到T[d-1]为止。

探查过程终止于三种情况：

* 若当前探查的单元为空，则表示查找失败（若是插入则将key写入其中）；
* 若当前探查的单元中含有key，则查找成功，但对于插入意味着失败；
* 若探查到T[d-1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败(此时表满)。

利用开放地址法的一般形式，线性探查法的探查序列为： `h i =(h(key)+i)％m 0≤i≤m-1 //即d i =i`

用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：

1. 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。
2. 按上述算法建立起来的哈希表，删除工作非常困难。假如要从哈希表 HT 中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能标上已被删除的标记，否则，将会影响以后的查找。
3. 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。

####    二次探测再散列

$$
di=1^2，-1^2，2^2，-2^2，…，k^2，-k^2    ( k<=m/2 )
$$

这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。

#### 随机探测

di=伪随机数序列；

具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），生成一个伪随机序列，并给定一个随机数做起点，每次去加上这个伪随机数++就可以了。

### 拉链法

拉链法解决冲突的方法是：将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。

与开放定址法相比，拉链法有如下几个优点：

1. 拉链法处理冲突简单 ，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
2. 由于拉链法中各链表上的 结点空间是动态申请的 ，故它更适合于造表前无法确定表长的情况；
3. 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
4. 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

拉链法的缺点如下：
指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。

### 再散列法

再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置

缺点：每次冲突都要重新散列，计算时间增加。
